from __future__ import unicode_literals

from django.contrib import admin
from django.contrib.auth import get_user_model
from accounts import get_profile_model, ProfileNotConfigured

from mezzanine.core.admin import SitePermissionUserAdmin
from mezzanine.conf import settings
from mezzanine.utils.email import send_approved_mail, send_verification_mail

from sample_bind.models import Bind
from mezzanine.core.admin import TabularDynamicInlineAdmin, StackedDynamicInlineAdmin
from django.utils.translation import ugettext, ugettext_lazy as _
from sms.conf import settings as sms_settings
from sms.models import MyProfile
import top.api
try:
    import json
except ImportError:
    from django.utils import simplejson as json

User = get_user_model()

user_list_display = SitePermissionUserAdmin.list_display
user_list_display += ("is_active", "date_joined", "last_login")


class UserProfileAdmin(SitePermissionUserAdmin):

    list_display = user_list_display
    actions = ['send_account']

    def send_account(self, request, queryset):
        """
        1、批量操作发送账号信息短信
        2、调用阿里大鱼发送通知短信，密钥保存于sms conf中
        :param request:
        :param queryset:
        :return:
        """
        rows_sent = 0
        for obj in queryset:
            if not obj.last_login:
                rows_sent += 1
                phone_num = int(MyProfile.objects.get(user_id=obj.id).mobile_phone)
                username = obj.username

                appkey = sms_settings.ALIDAYU_APPKEY
                secret = sms_settings.ALIDAYU_SECRET
                req = top.api.AlibabaAliqinFcSmsNumSendRequest()
                req.set_app_info(top.appinfo(appkey, secret))

                # req.extend = "123456"
                req.sms_type = "normal"
                req.sms_free_sign_name = "锐翌医学"
                req.sms_param = json.dumps({'username': username})
                req.rec_num = phone_num
                req.sms_template_code = "SMS_25710337"
                try:
                    resp = req.getResponse()
                    self.message_user(request, _("%s 's sms has been sent successfully") % username)
                except Exception as e:
                    self.message_user(request, _("Fail to send sms: %s 's phone %s, error_info: %s") %
                                      (username, phone_num, e))

        if rows_sent == 1:
            message_bit = _("1 user")
        else:
            message_bit = _("%s users") % rows_sent
        self.message_user(request, _("Successfully send account sms to %s") % message_bit)
    send_account.short_description = _("Send account sms to selected users")

    def save_model(self, request, obj, form, change):
        """
        If the ``ACCOUNTS_APPROVAL_REQUIRED`` setting is ``True``,
        send a notification email to the user being saved if their
        ``active`` status has changed to ``True``.
        If the ``ACCOUNTS_VERIFICATION_REQUIRED`` setting is ``True``,
        send a verification email instead.
        """
        must_send_verification_mail_after_save = False
        if change and settings.ACCOUNTS_APPROVAL_REQUIRED:
            if obj.is_active and not User.objects.get(id=obj.id).is_active:
                if settings.ACCOUNTS_VERIFICATION_REQUIRED:
                    # Accounts verification requires an inactive account
                    obj.is_active = False
                    # The token generated by send_verification_mail()
                    # must match the _saved_ User object,
                    # so postpone send_verification_mail() until later
                    must_send_verification_mail_after_save = True
                else:
                    send_approved_mail(request, obj)
        super(UserProfileAdmin, self).save_model(request, obj, form, change)
        if must_send_verification_mail_after_save:
            user = User.objects.get(id=obj.id)
            send_verification_mail(request, user, "signup_verify")


try:
    class ProfileInline(admin.StackedInline):
        model = get_profile_model()
        can_delete = False
        template = "admin/profile_inline.html"
        extra = 0

        def get_min_num(self, request, obj=None, **kwargs):
            """This causes profile forms to be shown when editing but hidden
            when creating. If min_num is fixed at 1, Django's initial user
            creation form fails if the profile model has a required field."""
            return 0 if obj is None else 1

    class BindInline(TabularDynamicInlineAdmin):
        model = Bind
        fields = ('code', 'full_name',)
        raw_id_fields = ('code',)
        extra = 1
    UserProfileAdmin.inlines = (ProfileInline, BindInline,)
    UserProfileAdmin.fieldsets = (
        (None, {'fields': ('username', 'password')}),
        (_('Important dates'), {'fields': ('last_login', 'date_joined')}),
        (_('Personal info'), {'fields': ('first_name', 'last_name', 'email')}),
    )
except ProfileNotConfigured:
    pass


if User in admin.site._registry:
    admin.site.unregister(User)
admin.site.register(User, UserProfileAdmin)
